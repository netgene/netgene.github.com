---
layout: post
title: golang特性
date: 2016-02-05 18:28:58
categories:
- golang
- 语言与设计
tags:
---

go语言编程，主要语言特性：

- 自动垃圾回收gc；
- 更丰富的内置类型; 类型自动推导； 数组 字符串 字典map 数组切片slice。
- 函数多返回值，多重赋值；，既不用再区分参数列表中哪几个用于输入，哪几个用于输出，也不用再只为了返回多个值而专门定义一个数据结构。
- 错误处理；defer panic recover
- 匿名函数和闭包；
- 类型和接口；struct interface 不支持继承和重载 只支持最基本的类型组合composition
- 并发编程；goroutine channel
- 反射；java
- 语言交互性；cgo
- 工程管理，包概念； 自分析依赖免去手动Makefile go run, go build 
- 单元测试:xx_test.go


(Go语言之父谈Go：大道至简)[http://www.csdn.net/article/2012-07-05/2807113-less-is-exponentially-more]

Go从C和C++简化的功能：

- 规范的语法（不需要符号表来解析）
- 垃圾回收（独有）
- 无头文件
- 明确的依赖
- 无循环依赖
- 常量只能是数字
- int和int32是两种类型
- 字母大小写设置可见性（letter case sets visibility）
- 任何类型（type）都有方法（不是类型）
- 没有子类型继承（不是子类）
- 包级别初始化以及明确的初始化顺序
- 文件被编译到一个包里
- 包package-level globals presented in any order
- 没有数值类型转换（常量起辅助作用）
- 接口隐式实现（没有“implement”声明）
- 嵌入（不会提升到超类）
- 方法按照函数声明（没有特别的位置要求）
- 方法即函数
- 接口只有方法（没有数据）
- 方法通过名字匹配（而非类型）
- 没有构造函数和析构函数
- postincrement（如++i）是状态，不是表达式
- 没有preincrement(i++)和predecrement
- 赋值不是表达式
- 明确赋值和函数调用中的计算顺序（没有“sequence point”）
- 没有指针运算
- 内存一直以零值初始化
- 局部变量取值合法
- 方法中没有“this”
- 分段的堆栈
- 没有静态和其它类型的注释
- 没有模板
- 没有异常
- 内建string、slice和map
- 数组边界检查

因为有这么多功能的简化，我相信Go比C和C++更有表现力。Less can be more！


中文指南
https://github.com/golang/go/wiki#getting-started-with-go
https://tour.go-zh.org/welcome/1
http://studygolang.com
struct array slice map
defer closures
methods(no class) interface
goroutine channel 缓冲channel
package chan panic
没有继承，只有组合。可以通过匿名组合达到类似继承的效果
为特定类型定义函数，即为类型对象定义方法  
实现多态 函数也是“值”  函数也是“类型”    可以对指定函数类的变量赋值函数名称
结构体嵌套变成一维引用

如果我们的goroutine是一匹不知疲倦的牛，一直孜孜不倦地工作的话，如何在主流程中告知并等待它退出呢

，go是按照CSP来实现并发的,提倡“通过通信来共享内存，而非通过共享内存来通信”的原则。channel就是为此而来。

结构体赋值
支持多返回值
不固定参数

GO标准库中还提供了sync包，其中有基本的mutex说，还有RMutex这样的读写锁，还有Once，WaiterGroup等东西。基本满足日常中对锁的需求了

写大工程请搜索: Golang项目目录结构组织

总结下来，这东西就是一个工程工具，各种好用，但是从设计角度讲各种粗糙，没必要过度高估。它算的上工程实践中的好朋友。在写服务端时，它是把利器，至少在写服务端程序时，我自己感觉如此。

https://gobyexample.com/

并发编程
groutine    channel   chan  sync.Mutex interface

sudo apt-get install python-software-properties
sudo add-apt-repository ppa:gophers/go
sudo apt-get update
sudo apt-get install golang-stable git-core mercurial

http://blog.studygolang.com/2012/12/go%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/ 项目结构
http://studygolang.com/articles/4540  go语言文档

最迷你
https://segmentfault.com/a/1190000002982372 
一个go的迷你网络库
https://github.com/sniperHW/kendynet-go

http://my.oschina.net/feilonge/blog/79079 
用Golang写网络库的一些想法

网络库思考：
golang本身就是一个网络库，所以不用再去考虑事件驱动的异步回调方式。Golang的Goroutine机制其实和其他语言中的协程+事件驱动达到同样的效果（楼上也说明了，golang底部正是用的epoll和类似线程池的东东）。至于选择 Peer Thread Peer EventPoll （libuv,libev,muduo,tbnet） 还是选择协程(skynet,lua,golang)的方式，还是看应用和自己熟悉吧。如果说在Golang中，感觉使用标准库的net配合goroutine+channel就足以写应用了，不用再对网络层和驱动做过多考虑。

http://studygolang.com/articles/2423  goroutine + channel

Golang 的并发与 Erlang、Scala、Node.js 和 Python 的并发模型相比有何特点？
https://www.zhihu.com/question/21461752 


http://www.tuicool.com/articles/I7RjUvQ goroutine 开携程 由GO去协调  都是阻塞的调用 无需维护状态


http://studygolang.com/articles/581  net 包
http://www.tuicool.com/articles/I7RjUvQ 
Golang服务器的网络层实现

http://studygolang.com/articles/1855  
goroutine与调度器
我们都知道Go语言是原生支持语言级并发的，这个并发的最小逻辑单元就是goroutine。goroutine就是Go语言提供的一种用户态线程，当然这种用户态线程是跑在内核级线程之上的。当我们创建了很多的goroutine，并且它们都是跑在同一个内核线程之上的时候，就需要一个调度器来维护这些goroutine，确保所有的goroutine都使用cpu，并且是尽可能公平的使用cpu资源。

这个调度器的原理以及实现值得我们去深入研究一下。支撑整个调度器的主要有4个重要结构，分别是M、G、P、Sched，前三个定义在runtime.h中，Sched定义在proc.c中。

	* Sched结构就是调度器，它维护有存储M和G的队列以及调度器的一些状态信息等。
	* M代表内核级线程，一个M就是一个线程，goroutine就是跑在M之上的；M是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息。
	* P全称是Processor，处理器，它的主要用途就是用来执行goroutine的，所以它也维护了一个goroutine队列，里面存储了所有需要它来执行的goroutine，这个P的角色可能有一点让人迷惑，一开始容易和M冲突，后面重点聊一下它们的关系。
	* G就是goroutine实现的核心结构了，G维护了goroutine需要的栈、程序计数器以及它所在的M等信息。


理解M、P、G三者的关系对理解整个调度器非常重要，我从网络上找了一个图来说明其三者关系：


通过channel通知 goroutine http://www.cnblogs.com/getong/archive/2013/03/19/2970045.html
