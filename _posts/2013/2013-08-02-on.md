---
layout: post
title: 时间复杂度
date: 2013-08-02 18:28:58
categories:
- algorithm
tags:
---

![stcrm](/images/posts/2013-08-02-on-1.jpg)

常见的算法时间复杂度由小到大依次为：
　　Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!)

http://www.howzhi.com/note/2846
现在，我们来比较一下不同算法的运算速度：对数级 线性级 平方级 指数级
假设输入值大小为n = 1000位

	* 对数级(Logarithm)要花10纳秒(nanosecs)      O(logn)
	* 线性级(Linear)要花1微秒(microsecs)             O(n)    --
	* 二次方级(Quadratic)要花1厘秒(millisecs)       O(n2)   --
	* 指数级(Exponential)要花10^284年！              O(2n)  --汉诺塔
	* 


常见算法时间复杂度：
O(1): 表示算法的运行时间为常量
O(n): 表示该算法是线性算法
O(㏒2n): 二分搜索算法
O(n㏒2n): 快速排序算法
O(n2): 对数组进行排序的各种简单算法，例如直接插入排序的算法。N的二次方级
O(n3): 做两个n阶矩阵的乘法运算   
O(2n): 求具有n个元素集合的所有子集的算法，，汉诺塔 指数级
O(n!): 求具有N个元素的全排列的算法
          优<---------------------------<劣
         O(1)<O(㏒2n)<O(n)< O(n㏒2n): <O(n2)<O(2n)


求解算法的时间复杂度的具体步骤是：　　⑴ 找出算法中的基本语句；
　　算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。
　　⑵ 计算基本语句的执行次数的数量级；
　　只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。
　　⑶ 用大Ο记号表示算法的时间性能。
　　将基本语句执行次数的数量级放入大Ο记号中。
　　如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加。例如：
　　for (i=1; i<=n; i++)
　　x++;
　　for (i=1; i<=n; i++)
　　for (j=1; j<=n; j++)
　　x++;
　　第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(n2)，则整个算法的时间复杂度为Ο(n+n2)=Ο(n2)。
　　常见的算法时间复杂度由小到大依次为：
　　Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!)
Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。Ο(log2n)、Ο(n)、Ο(nlog2n)、Ο(n2)和Ο(n3)称为多项式时间，而Ο(2n)和Ο(n!)称为指数时间。计算机科学家普遍认为前者是有效算法，把这类问题称为P类问题，而把后者称为NP问题。
这只能基本的计算时间复杂度，具体的运行还会与硬件有关。
 
上面的这部分内容是比较可靠的，理解的时候，可以参看着下面的这部分内容。
在计算算法时间复杂度时有以下几个简单的程序分析法则:
1.对于一些简单的输入输出语句或赋值语句,近似认为需要O(1)时间
2.对于顺序结构,需要依次执行一系列语句所用的时间可采用大O下"求和法则"
求和法则:是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1(n)+T2(n)=O(max(f(n), g(n)))
特别地,若T1(m)=O(f(m)), T2(n)=O(g(n)),则 T1(m)+T2(n)=O(f(m) + g(n))
3.对于选择结构,如if语句,它的主要时间耗费是在执行then字句或else字句所用的时间,需注意的是检验条件也需要O(1)时间
4.对于循环结构,循环语句的运行时间主要体现在多次迭代中执行循环体以及检验循环条件的时间耗费,一般可用大O下"乘法法则"
乘法法则: 是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1*T2=O(f(n)*g(n))
5.对于复杂的算法,可以将它分成几个容易估算的部分,然后利用求和法则和乘法法则技术整个算法的时间复杂度
另外还有以下2个运算法则:
(1) 若g(n)=O(f(n)),则O(f(n))+ O(g(n))= O(f(n))
(2) O(Cf(n)) = O(f(n)),其中C是一个正常数
可以用以上法则对下面程序段进行简单分析
①for (i=0; i<n; i++)
② for (j=0; j<n; j++)
{
③ c[i][j] = 0;
④ for (k=0; k<n; k++)
⑤ c[i][j]= c[i][j]+ a[i][k]* b[k][j];/ * T5(n) = O(1) */
}
第①条与②③④⑤是循环嵌套T1(n)*T2(n)* (T3(n)+ T4(n)* T5(n))= O(n*n*n)即为整个算法的时间复杂度
O(1)<O(log2n)<O(n)<O(n log2 n)<O(n^2)<O(n^3)<O(2^n)
