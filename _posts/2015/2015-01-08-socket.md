---
layout: post
title: socket简述
date: 2015-01-08 18:28:58
categories:
- 网络与安全
tags:
---


默认 socket 是阻塞的，读写函数 read, readv, recv, recvfrom, recvmsg 以及 write, writev, send, sendto, sendmsg 都有可能会阻塞。可以将 socket 描述字设为非阻塞，这样，当 socket 描述字未就绪时，调用以上读写函数将会返回 EWOULDBLOCK 或 EAGAIN 。

1. 同步，就是我调用一个功能，该功能没有结束前，我死等结果。
2. 异步，就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）
3. 阻塞，      就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。
4. 非阻塞，  就是调用我（函数），我（函数）立即返回，通过select通知调用者

同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞！
阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回！

http://blog.csdn.net/jwybobo2007/article/details/6164362
 一.发送选用send（这里特指TCP）以及sendto（这里特指UDP）来描述
    首先需要说明的是，不管阻塞还是非阻塞，在发送时都会将数据从应用缓冲区拷贝到内核缓冲区（SO_RCVBUF选项声明，除非缓冲区大小为0）。我在网络上看到某些人说，阻塞就是将数据真正发送给对方，并且阻塞是发生在需要把前面的所有数据全部发送出去，然后再发送本次的，而非阻塞则是拷贝到发送缓冲区。我不得不说，上面的这种说法是错误的。
    在阻塞模式下send操作将会等待所有数据均被拷贝到发送缓冲区后才会返回。
    如果当前发送缓冲总大小为8192，已经拷贝到缓冲的数据为8000，那剩余的大小为192，现在需要发送2000字节数据，那阻塞发送就会等待缓冲区足够把所有2000字节数据拷贝进去，如第一次拷贝进192字节，当缓冲区成功发送出1808字节后，再把应用缓冲区剩余的1808字节拷贝到内核缓冲，而后send操作返回成功发送字节数。
    从上面的过程不难看出，阻塞的send操作返回的发送大小，必然是你参数中的发送长度的大小。
    在阻塞模式下的sendto操作不会阻塞。
    关于这一点的原因在于：UDP并没有真正的发送缓冲区，它所做的只是将应用缓冲区拷贝给下层协议栈，在此过程中加上UDP头，IP头，所以实际不存在阻塞。
    在非阻塞模式下send操作调用会立即返回。
    关于立即返回大家都不会有异议。还是拿阻塞send的那个例子来看，当缓冲区只有192字节，但是却需要发送2000字节时，此时调用立即返回，并得到返回值为192。从中可以看到，非阻塞send仅仅是尽自己的能力向缓冲区拷贝尽可能多的数据，因此在非阻塞下send才有可能返回比你参数中的发送长度小的值。
    如果缓冲区没有任何空间时呢？这时肯定也是立即返回，但是你会得到WSAEWOULDBLOCK/E WOULDBLOCK 的错误，此时表示你无法拷贝任何数据到缓冲区，你最好休息一下再尝试发送。
    在非阻塞模式下sendto操作 不会阻塞（与阻塞一致，不作说明）。
 
  二.接收选用recv（这里特指TCP）以及recvfrom（这里特指UDP）来描述
    在阻塞模式下recv，recvfrom操作将会阻塞 到缓冲区里有至少一个字节（TCP）或者一个完整UDP数据报才返回。
    在没有数据到来时，对它们的调用都将处于睡眠状态，不会返回。
    在非阻塞模式下recv，recvfrom操作将会立即返回。
    如果缓冲区 有任何一个字节数据（TCP）或者一个完整UDP数据报，它们将会返回接收到的数据大小。而如果没有任何数据则返回错误 WSAEWOULDBLOCK/E WOULDBLOCK。
 
